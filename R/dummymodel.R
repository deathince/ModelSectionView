
#' generate dummy model function
#' this function will pull some preset from written model
#'
#' @param id the preset id
#'
#' @return
#' list$name     the name of id corresponded preset.
#' list$points     the points located in this preset.
#' list$connections      the connections between points
#' @export
#'
#' @examples
dummymodel <- function(id = 0){
  if (id == 0){
    name = "cube"
    points = matrix(c(1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,1,-1), nrow = 8, ncol = 3)
    connections = matrix(c(1,0))
  }
  return(list(name = name, points = points, connections = connections))
}


#' simplify model function
#' combining duplicated or close control points
#'
#' @param points  the P * 3 matrix that is generated by other base functions
#' @param connections the P * P matrix indicate the connections between points
#'
#' @return
#' points    the (P - x) * 3 matrix, combined x pair points in simplifying procedure
#' connections   the (P - x) * (P - x) matrix indicate the connections between new points
#' @export
#'
#' @examples
simplifymodel <- function(points, connections){
  # this function need to have loop of loop to iterate every pair of points, therefore using C++ is recommended
  # underconstruction
  return (list(points = points, connections = connections))
}



#' baseshape generator function
#' generating a line, trangle or square
#'
#' @param point an integer that is either 2, 3, or 4 to determine init number points
#'
#' @return a line, triangle or square depend on input
#' @export
#'
#' @examples
baseshape <- function(point = 2){
  if (point == 2){
    name = "line"
    points = matrix(c(1,-1,0,0,0,0), nrow = 2, ncol = 3)
    connections = matrix(c(0,1,1,0), nrow = 2, ncol = 2)
  }
  else if (point == 3){
    name = "triangle"
    points = matrix(c(1,-1,0,0,0,1,0,0,0), nrow = 3, ncol = 3)
    connections = matrix(c(0,1,1,1,0,1,0,1,1), nrow = 3, ncol = 3)
  }
  else{
    name = "square"
    points = matrix(c(1,1,-1,-1,1,-1,1,-1,0,0,0,0), nrow = 4, ncol = 3)
    connections = matrix(c(0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0), nrow = 4, ncol = 4)
  }
  return (list(name = name, points = points, connections = connections))
}


#' the new surface generator function
#'
#' @param controlpoints the n * 3 matrix that lay on the same plane
#'
#' @return   controlpoints  same as input if no exception exist
#'           surface        an 1 * 3 matrix or 3 len vector that represent which points create triangle surface.
#' @export
#'
#' @examples
baseshapenew <-function(controlpoints){
  size = length(controlpoints)
  if (size < 3){
    stop("the control points can not create a surface")
  }
  else if (size > 3){
    # perform safe check that all control points lay on same surface
  }
  surface = c(1,2,3)
  return(list(points = controlpoints, surface = surface))
}

#' shift function
#'
#' @param points the P * 3 matrix that is generated by other base functions
#' @param shift an len 3 vector indicating how much we want to shift, default is (0,0,0)
#' @param shiftto an len 3 vector indicate where do we want to shift model to. default is NULL
#'
#' @return the points that is shifted by shift amount. or one of the closest point shift to shiftto location.
#' @export
#'
#' @examples
#' shift(matrix(c(0,0,1),nrow = 1),c(1,1,1)) # return matrix(1,1,2) that every point in matrix shift (1,1,1) direction
shift <- function(points,shift = c(0,0,0), shiftto = NULL){
  # perform shift if no shiftto location is given.
  if (is.null(shiftto)){
    if (length(shift) != 3){
      return(points)
    }
    newpoint = t(t(points) + shift)
    return(newpoint)
  }
  else{
    # find the distance
    if (length(shiftto) != 3){
      # error location to shift
      return(points)
    }
    distance = rowSums(t(t(points) - shiftto))
    shift = -1 * points(which.min(distance))
    newpoint = t(t(points) + shift)
    return(newpoint)
  }
}


#' spin function
#' rotate model at (0,0,0) axis with provided direction
#' @param points  the P * 3 matrix that is generated by other base functions
#' @param direction  an integer that is either 0, 1, 2 corresponding xy, xz, yz plane we perform rotate
#' @param angle    how much we rotate the graph in radian, default is half pi radian or 90 degree
#'
#' @return newpoints   the P * 3 matrix of points after the rotation is performed.
#' @export
#'
#' @examples
spin <- function(points, direction = 0, angle = pi / 2){
  # depending on the direction, transforming the point on a plane with polar system
  # then perform spin, transform back to xyz axis system

  if (direction == 0){
    # xy plane
    distance = sqrt(points[, 1]^2 + points[, 2]^2)
    indangle = tan(points[, 2] / points[, 1])
    points[, 1] = distance * cos(indangle + angle)
    points[, 2] = distance * sin(indangle + angle)
  }
  else if (direction == 1){
    # xz plane
    distance = sqrt(points[, 1]^2 + points[, 3]^2)
    indangle = tan(points[, 3] / points[, 1])
    points[, 1] = distance * cos(indangle + angle)
    points[, 3] = distance * sin(indangle + angle)
  }
  else if (direction == 2){
    # yz plane
    distance = sqrt(points[, 3]^2 + points[, 2]^2)
    indangle = tan(points[, 2] / points[, 3])
    points[, 3] = distance * cos(indangle + angle)
    points[, 2] = distance * sin(indangle + angle)
  }



  newpoints = points


  return(newpoints)
}

#' join model function
#'
#' @param points1 the model1 control points
#' @param surface1 the model1 surface
#' @param points2 the model2 control points
#' @param surface2 the model2 surface
#'
#' @return points the combined control points
#'         surface the combined surface
#' @export
#'
#' @examples
join <- function(points1, surface1, points2, surface2){
  if(ncol(points1) != ncol(points2)){
    stop("the vertex is incorrect")
  }
  if (ncol(surface1) != ncol(surface2)){
    stop("the surface is incorrect")
  }
  len = nrow(points1)
  return (list(points = rbind(points1,points2), surface = rbind(surface1,(surface2+len))))
}
