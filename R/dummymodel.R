
#' generate dummy model function
#' this function will pull some preset from written model
#'
#' @param id the preset id
#'
#' @return
#' list$name     the name of id corresponded preset.
#' list$points     the points located in this preset.
#' list$connections      the connections between points
#' @export
#'
#' @examples
dummymodel <- function(id = 0){
  if (id == 0){
    name = "cube"
    points = matrix(c(1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,1,-1), nrow = 8, ncol = 3)
    connections = matrix(c(1,0))
  }
  return(list(name = name, points = points, connections = connections))
}


#' simplify model function
#' combining duplicated or close control points
#'
#' @param points  the P * 3 matrix that is generated by other base functions
#' @param connections the P * P matrix indicate the connections between points
#'
#' @return
#' points    the (P - x) * 3 matrix, combined x pair points in simplifying procedure
#' connections   the (P - x) * (P - x) matrix indicate the connections between new points
#' @export
#'
#' @examples
simplifymodel <- function(points, connections){
  # this function need to have loop of loop to iterate every pair of points, therefore using C++ is recommended
  # underconstruction
  return (list(points = points, connections = connections))
}



#' baseshape generator function
#' generating a line, trangle or square
#'
#' @param point an integer that is either 2, 3, or 4 to determine init number points
#'
#' @return a line, triangle or square depend on input
#' @export
#'
#' @examples
baseshape <- function(point = 2){
  if (point == 2){
    name = "line"
    points = matrix(c(1,-1,0,0,0,0), nrow = 2, ncol = 3)
    connections = matrix(c(0,1,1,0), nrow = 2, ncol = 2)
  }
  else if (point == 3){
    name = "triangle"
    points = matrix(c(1,-1,0,0,0,1,0,0,0), nrow = 3, ncol = 3)
    connections = matrix(c(0,1,1,1,0,1,0,1,1), nrow = 3, ncol = 3)
  }
  else{
    name = "square"
    points = matrix(c(1,1,-1,-1,1,-1,1,-1,0,0,0,0), nrow = 4, ncol = 3)
    connections = matrix(c(0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0), nrow = 4, ncol = 4)
  }
  return (list(name = name, points = points, connections = connections))
}


#' shift function
#'
#' @param points the P * 3 matrix that is generated by other base functions
#' @param shift an len 3 vector indicating how much we want to shift, default is (0,0,0)
#' @param shiftto an len 3 vector indicate where do we want to shift model to. default is NULL
#'
#' @return the points that is shifted by shift amount. or one of the closest point shift to shiftto location.
#' @export
#'
#' @examples
#' shift(matrix(c(0,0,1),nrow = 1),c(1,1,1)) # return matrix(1,1,2) that every point in matrix shift (1,1,1) direction
shift <- function(points,shift = c(0,0,0), shiftto = NULL){
  # perform shift if no shiftto location is given.
  if (is.null(shiftto)){
    if (length(shift) != 3){
      return(points)
    }
    newpoint = t(t(points) + shift)
    return(newpoint)
  }
  else{
    # find the distance
    if (length(shiftto) != 3){
      # error location to shift
      return(points)
    }
    distance = rowSums(t(t(points) - shiftto))
    shift = -1 * points(which.min(distance))
    newpoint = t(t(points) + shift)
    return(newpoint)
  }
}


#' spin function
#'
#' @param points  the P * 3 matrix that is generated by other base functions
#' @param direction  an integer that is either 0, 1, 2 corresponding x, y, z axis we perform rotate
#' @param angle    how much we rotate the graph, default is 90 degree
#'
#' @return newpoints   the P * 3 matrix of points after the rotation is performed.
#' @export
#'
#' @examples
spin <- function(points, direction = 0, angle = 90){
  # depending on the direction, transforming the point on a plane with polar system

  # then perform spin, transform back to xyz axis system


  newpoints = points


  return(newpoints)
}
